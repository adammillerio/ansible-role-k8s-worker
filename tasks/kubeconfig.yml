---
- name: check if the kubeconfig already exists
  local_action:
    module: stat
    path: "{{ files_path }}/{{ item }}.kubeconfig"
  register: kubeconfig_stats
  with_items: "{{ play_hosts }}"

- name: create the client kubeconfig
  local_action: "shell kubectl config set-cluster local --certificate-authority=ca.pem --embed-certs=true --server=https://{{ k8s_internal_apiserver_host }}:6443 --kubeconfig={{ item.item }}.kubeconfig chdir={{ files_path }}"
  when: item.stat.exists == False
  with_items: "{{ kubeconfig_stats.results }}"

- name: set the client kubeconfig credentials
  local_action: "shell kubectl config set-credentials kubelet --client-certificate={{ item.item }}.pem --client-key={{ item.item }}-key.pem --embed-certs=true --kubeconfig={{ item.item }}.kubeconfig chdir={{ files_path }}"
  when: item.stat.exists == False
  with_items: "{{ kubeconfig_stats.results }}"

- name: set the client kubeconfig context
  local_action: "shell kubectl config set-context service-account-context --cluster=local --user=kubelet --kubeconfig={{ item.item }}.kubeconfig chdir={{ files_path }}"
  when: item.stat.exists == False
  with_items: "{{ kubeconfig_stats.results }}"

- name: use the client kubeconfig context
  local_action: "shell kubectl config use-context service-account-context --kubeconfig={{ item.item }}.kubeconfig chdir={{ files_path }}"
  when: item.stat.exists == False
  with_items: "{{ kubeconfig_stats.results }}"

# TODO: Fix making public to get around files being generated as remote_user
- name: make the client kubeconfig file public readable
  local_action:
    module: file
    path: "{{ files_path }}/{{ item }}.kubeconfig"
    mode: 0664
  with_items: "{{ play_hosts }}"

- name: copy the client kubeconfig to the host
  copy:
    src: "{{ files_path }}/{{ item }}.kubeconfig"
    dest: "/root/client.kubeconfig"
  become: true
  with_items: "{{ play_hosts }}"

- name: check if the proxy kubeconfig already exists
  local_action:
    module: stat
    path: "{{ files_path }}/kube-proxy.kubeconfig"
  register: proxy_kubeconfig_stat

- name: create the proxy kubeconfig
  local_action: "shell kubectl config set-cluster local --certificate-authority=ca.pem --embed-certs=true --server=https://{{ k8s_internal_apiserver_host }}:6443 --kubeconfig=kube-proxy.kubeconfig chdir={{ files_path }}"
  when: proxy_kubeconfig_stat.stat.exists == False

- name: set the proxy kubeconfig credentials
  local_action: "shell kubectl config set-credentials kube-proxy --client-certificate=kube-proxy.pem --client-key=kube-proxy-key.pem --embed-certs=true --kubeconfig=kube-proxy.kubeconfig chdir={{ files_path }}"
  when: proxy_kubeconfig_stat.stat.exists == False

- name: set the proxy kubeconfig context
  local_action: "shell kubectl config set-context service-account-context --cluster=local --user=kube-proxy --kubeconfig=kube-proxy.kubeconfig chdir={{ files_path }}"
  when: proxy_kubeconfig_stat.stat.exists == False

- name: use the proxy kubeconfig context
  local_action: "shell kubectl config use-context service-account-context --kubeconfig=kube-proxy.kubeconfig chdir={{ files_path }}"
  when: proxy_kubeconfig_stat.stat.exists == False

# TODO: Fix making public to get around files being generated as remote_user
- name: make the proxy kubeconfig file public readable
  local_action:
    module: file
    path: "{{ files_path }}/kube-proxy.kubeconfig"
    mode: 0664

- name: copy proxy kubeconfig to the host
  copy:
    src: "{{ files_path }}/kube-proxy.kubeconfig"
    dest: "/root/kube-proxy.kubeconfig"
  become: true

